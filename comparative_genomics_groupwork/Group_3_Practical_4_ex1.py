import re
from Bio.Blast import NCBIXML
import csv
import argparse

def BLASTparser(input_file,verbosity,header,extend):
    handle = open(input_file)
    blast_records = NCBIXML.parse(handle)
    records = []
    csv_list = []

    if verbosity==0:
        csv_header = ['Query', 'Hit']
    elif verbosity==1:
        csv_header = ['Query', 'Hit', 'Score']
    else:
        csv_header = ['Query', 'Hit', 'Length', 'Score', 'Expect', 'QueryStart', 'QueryEnd', 'SubjectStart', 'SubjectEnd']

    if header:
        csv_list.append(csv_header)

    oldrow=["","","","","","","","",""]

    for blast_record in blast_records:

        query = blast_record.query
        
        for alignment in blast_record.alignments:

            hit = re.compile ("gnl\|BL_ORD_ID\|\d* ").sub ("", alignment.title)
            length = alignment.length
            
            hsp = alignment.hsps[0]
            score = hsp.score
            expect = hsp.expect
            querystart = hsp.query_start
            queryend = hsp.query_end
            subjectstart = hsp.sbjct_start
            subjectend = hsp.sbjct_end
            
            if verbosity==0:
                row=[query,hit]
            elif verbosity==1:
                row=[query,hit,score]
            else:
                row = [query, hit, length, score, expect,querystart, queryend, subjectstart, subjectend]
            
            if extend==False:
                if oldrow[0]!=row[0]:
                    csv_list.append(row)
                    oldrow=row
            else:
                csv_list.append(row)

    return csv_list

def main(args):
    csv_list=BLASTparser(args.input,args.verbosity, args.header,args.extend)
    
    if args.suppress==False:
        with open(args.output, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerows(csv_list)
    
    if args.print==True:
        for i in range(len(csv_list)):
            print(csv_list[i])

if __name__ =='__main__':
    parser = argparse.ArgumentParser(description="Parses through an XML file generated by BLAST and converts it in .csv format, default mode only returns a csv containing a list of the best hit in the db for each sequence of the query, in the format: \n\norf_reference_1,its_best_match_in_the_db\norf_reference_2,its_best_match_in_the_db\n...,...\n...,...\n", formatter_class=argparse.RawTextHelpFormatter)
    #group = parser.add_mutually_exclusive_group()
    parser.add_argument("input", type=str, help="path or name of the input XML file")
    parser.add_argument("-o", "--output", type=str, help="path or name of the output file", default="out.csv")
    parser.add_argument("-p","--print" , action="store_true", help="if toggled prints the generated output while the script is running",default=False)
    parser.add_argument("-s", "--suppress", action="store_true", help="if toggled suppresses the production of an output file, useful if you want to print the output but not store it", default=False)
    parser.add_argument("-v", "--verbosity", action="count", help="increase output verbosity, if toggled one time the output format will be:\nQuery, Hit, Score\n\nif toggled more than once [e.g. -vv] the output will be:\n\nQuery, Hit, Length, Score, Expect, QueryStart, QueryEnd, SubjectStart, SubjectEnd\n\n", default=0)
    parser.add_argument("-b","--header" , action="store_true", help="if toggled adds a header at the beginning of the file",default=False)
    parser.add_argument("-e","--extend" , action="store_true", help="if toggled the output will not be only the best hit for each query, but all the hits recorded in the XML input",default=False)
    

    args = parser.parse_args()

    main(args)
